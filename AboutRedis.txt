Redis特性
1.速度快
	数据存在哪?
	数据存在了内存条
	什么语言写?
	用的是C语言
	线程模型?
	单线程
2.持久化
	Redis所有数据保存在内存中,对数据的更新将异步地保存到磁盘上
3.多种数据结构
	字符串
		重要API:get	set	del	O(1)
			incr(自增1) decr(自减1) O(1)
			incrby(incrby key k,key自增加k,如果key不存在,自增后get(key) = k) O(1)
			decrby(decrby key k, key自减k,如果key不存在,自减后get(key)=-k) O(1)
			mget mset 批量操作字符串O(n)
	哈希
		value中的key不能相同 value中的value可以相同
		重要API:hget hset hdel O(1)
				hexists (hexists key field 判断hash key 是否有field)
				hlen (hlen key 获取hash key field的数量)
				hmget hmset 批量操作哈希 O(n)
				hgetall (hgetall key 返回hash对应所有的field和value) O(n)
				hvals (hvals key 返回hash key对应所有field的value) O(n)
				hkeys (hkeys key 返回hash key对应所有field) O(n)
	列表
		特点:有序 可以重复
		重要API:rpush 从右边开始插入 O(1)
				lpush 从左边开始插入 O(1)
				linsert (linsert key before|after value newValue 在list指定的前|后插入newValue) O(n)
				lpop 从左边弹出一个元素 O(1)
				rpop 从右边弹出一个元素 O(1)
				lrem (lrem key count value 根据count值 从列表中删除所有value相等的项)
					(1)count>0 从左到右 删除最多count个value相等的项
					(2)count<0 从右到左 删除最多count个value相等的项
					(3)count=0 删除所有等于value的项
				ltrim (ltrim key start end 按照索引范围修剪列表)
				lrange (lrange key start end 获取列表指定范围内所有item 注意这里包含end)
				lindex (lindex key index 按照列表索引获取item)
				llen (llen key 获取列表的长度) O(1)
				lset (lset key index newValue 设置列表指定索引值为newValue)
	集合
		特点:无序(不能通过索引或下标来操作 存的value值为element) 无重复 可以进行集合间操作
		重要API:sadd (sadd key element 向集合key添加新的element，如果element已经存在 则添加失败)
				srem (srem key element 将集合key中的element移除掉)
				scard 计算集合大小
				sismember 判断element是否存在集合中
				srandmember 从集合中随机挑选一个element
				spop 从集合中随机弹出一个element(区别于上面的srandmember,spop弹出element之后,element就不存在于集合中)
				smembers 取出集合中的所有element(无序 O(n)小心使用)
				sdiff 计算差集
				sinter 计算交集
				sunion 计算并集
				sdiff|sinter|sunion store destkey (将差集/交集/并集结果保存在destkey中)
	有序集合
		特点:有序(存的value值为 score+element) 无重复(score可以重复 element可以重复)
		重要API:zadd (zadd key score element 添加score和element)
				zrem (zrem key emelent 删除element)
				zscore (zscore key element 返回emelent的score)
				zincrby (zincrby key score element 增加或减少element的score)
				zcard 返回集合中的element个数
				zrank 获取element的排名
				zcount (zcount key minScore maxScore 返回有序集合内在指定分数范围内的个数)
				zdiffstore 计算差集
				zinterstore 计算交集
				zunionstore 计算并集
4.支持多种客户端语言
5.功能丰富
	发布订阅
	支持lua脚本
	支持事务
	支持pipeline
6."简单"
7.主从复制
8.高可用,分布式
	高可用(Redis-Sentinel)
	分布式(Redis-Cluster)
	
Redsi典型应用场景
1.缓存系统
2.计数器
3.消息队列系统
4.排行榜
5.社交网络
6.实时系统

Redis常用配置
1.daemonize(是否守护进程)
默认是no,建议设置为yes，启动日志会写到日志文件中
2.port
端口号,默认端口号是6379
3.logfile
日志名
4.dir
Redis工作目录,例如日志文件,持久化文件报错到该目录中

Redis启动方式
建议使用redis的配置文件启动
window下:
1.进入redis目录
2.创建一个config文件夹
3.复制redis.windows.conf 到config目录下 修改名为redis-6379.conf (因为实际生产中 一台服务器可能启动多个redis服务器)
3.按上面常用配置参数进行相应修改
4.返回redis目录 创建data目录 存放日志等信息
5.新建6379.log文件
7.启动redis服务端:redis-server.exe config/redis-6379.conf (启动完成之后去日志文件下查看启动日志 不会再像直接启动的时候将日志输入cli在控制台了)

Redis通用命令
1.keys (计算redis中所有的key)
keys * 
时间复杂度为O(n) redis是单线程 生产环境不能随便用这个命令 扫描所有的key可以使用scan命令
2.dbsize (计算redis中所有key的大小)
时间复杂度为O(1) redis内置一个计数器 会返回所有key的个数
3.exists key (判断一个key是否存在)
时间复杂度为O(1)
4.del key (删除key)
时间复杂度为O(1) 成功删除返回1 删除失败比如key不存在返回0
5.expire key (设置key的过期时间)
时间复杂度为O(1)
ttl key (查看key还有多长时间过期) -2代表key已经不存在 -1代表key存在并且没有过期时间
presist (去除key的过期时间)
6.type key (查看key的数据类型)
时间复杂度为O(1)

Redis其它功能
1.慢查询
	生命周期:
	1.客户端发送命令
	2.Redis等待执行(单线程)
	3.执行命令
	4.返回结果
	慢查询发生在第3阶段(列如keys *)
	客户端超时不一定是慢查询,但慢查询是客户端超时的一个可能
2.pipline(流水线)
	将一批命令进行打包发送到服务端,服务端批量解决之后再按顺序返回给客户端
	使用pipline,减少了客户端发送命令到服务端以及服务端发送结果到客户端的一个时间(减少了网络时间)
	例如for循环使用中执行多次redis命令,效率就不如将这些命令打包使用pipline效率来的高
	注意:pipline每次只能作用在一个redis节点上,pipline区别于原生M操作不是原子的,但是返回的顺序是原子的
3.发布订阅
	角色:发布者(publisher)
		 订阅者(subscriber)
		 频道(channel)
	发布者(cli客户端)发送一个hello命令,通过服务端(channel)转发到订阅者(cli客户端)
	注意:一个新的订阅者是再订阅一个频道之后,它是收不到之前频道发布的消息,这里不能做一个消息的堆积,开发中要注意这种场景
	常用API：publish channel message(发布一条订阅消息)
			 subscribe [channel](订阅一个或多个频道)
			 unsubscribe [channel](取消一个或多个订阅频道)
	发布订阅和消息队列的区别:发布订阅是发布一条消息,所有订阅者都可以收到;消息队列是发布一条消息,订阅者去抢这条消息,只有一个订阅者可以收到(例如抢红包)		 
4.Bitmap(位图)
	redis是可以直接操作位数
	setbit key offset value(给位图指定索引设置值
	getbit key offset(获取位图指定索引的值)
	bigcount key [start end](获取位图指定范围start到end,单位为字节,如果不指定就是获取全部位值为1的个数)
5.HyperLogLog
	常用API:pfadd key element(向HyperLogLog添加元素)
			pfcount key(计算HyperLogLog的独立总数)
			pfmerge destkey sourcekey(合并多个HyperLogLog)
	做独立用户数的统计,注意:HyperLogLog是有错误率的,错误率为0.81%;HyperLogLog是不能取出单条数据的		
6.GEO(地理信息定位)
	存储经纬度,计算两地距离,范围计算等
	常用API:geoadd key longitude latitude member(增加地理位置信息)
			geopos key member(获取地理位置信息)
			geodist key member1,member2(获取两个地理位置的距离)
	

